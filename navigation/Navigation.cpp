#include "navigation.hpp"

using namespace std;
using namespace cv;

#define QUERY_FREQUENCY 10
#define MAX_SPEED_DISTANCE 100
#define TEST_VIDEO_PATH 'change.me'			//NOTE: This will eventually go away when we implement live feed

/* 	
*	This unit of code aims to utilize the functionality of roomba tracking and object detection to 
*	deliver navigation instructions to the UAV in the form of heading suggestions
*	NOTE: As of 05/18/17, neither object detection nor heading suggestions have been implemented, so
*	a simple interface has been substituted. Fake locations are generated by object_detection_mock and 
*	the generated suggestions are printed by the phony interface
*/

int main(int argc, char** argv) {
	
	vector<ConfidenceArc> arcs { new ConfidenceArc(), new ConfidenceArc(), new ConfidenceArc() };

	while(1) {
		//CALL FRAME ANALYSIS CODE input: IPLImage output: Point2f
		vector<Point2f> current_coords = get_positions(query_image());

		//PASS FIRST ROOMBA COORDS. TO PREDICTION ALGORITHM input: Point2f output: prediction
		predictNextFrame(current_coords, arcs);

		//UPDATE HEADING BASED OFF PREDICTION
		Prediction* tracked_roomba = arcs.at(0).getPrediction();
		double speed = dist_from_org(tracked_roomba->point) / MAX_SPEED_DISTANCE * tracked_roomba->confidence;
		speed = min(1,speed);
		double theta = tan(tracked_roomba->point.y / tracked_roomba->point.x) * PI / 180;
		update_heading(theta, speed);

	}
}

//	Retrieves the frame that is currently being outputted by the camera.
//	This will be the main method that needs to change when we swap over to a live feed
IplImage* query_image() {
	//TODO: Replace this w/ live feed
	static VideoPlayer* videoPlayer = cvCaptureFromFile(TEST_VIDEO_PATH);

	//Skip a number of frames based on the desired sampling frequency, loop video if necessary
	double fNum = cvGetCaptureProperty(video, CV_CAP_PROP_POS_FRAMES) + QUERY_FREQUENCY ;
	if (fNum < 0)
		fNum = 0;
	cvSetCaptureProperty(video, CV_CAP_PROP_POS_FRAMES,fNum);
	
	return cvQueryFrame(video);
}

double dist_from_org(Point2f* point) {
	return sqrt(pow(point.x,2) + pow(point.y,2));
}

void update_heading(double theta, double magnitude) {
	cout<<"Magnitude: " << magnitude << "\nTheta: " << theta << endl;
}